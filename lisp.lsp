(begin
  (define environment '())
  
  (define (loop output)
    (define rollback environment)
    (define (error message qualifier)
      (display message)
      (set! environment rollback)
      (loop qualifier))
    (define (bind-variable variable value)
      (define binding (cons variable value))
      (set! environment (cons binding environment)))
    (define (bind-parameters parameters arguments)
      (for-each bind-variable parameters arguments))
    (define (evaluate-sequence expressions)
      (define head (car expressions))
      (define tail (cdr expressions))
      (if (null? tail)
        (evaluate head)
        (evaluate-sequence tail)))
    (define (make-procedure parameters expression)
      (define lexical-scope environment)
      (lambda arguments
        (define dynamic-scope environment)
        (set! environment lexical-scope)
        (bind-parameters parameters arguments)
        (let ((value (evaluate expression)))
          (set! environment dynamic-scope)
          value)))
    (define (evaluate-application operator)
      (lambda operands
        (apply (evaluate operator) (map evaluate operands))))
    (define (evaluate-begin . expressions)
      (evaluate-sequence expressions))
    (define (evaluate-define variable expression)
      (define binding (cons variable '()))
      (set! environment (cons binding environment))
      (let ((value (evaluate expression)))
        (set-cdr! binding value)
        value))
    (define (evaluate-if predicate consequent alternative)
      (define boolean (evaluate predicate))
      (if (eq? boolean #f)
        (evaluate alternative)
        (evaluate consequent)))
    (define (evaluate-lambda parameters expression)
      (make-procedure parameters expression))
    (define (evaluate-set! variable expression)
      (define binding (assoc variable environment))
      (if binding
        (let ((value (evaluate expression)))
          (set-cdr! binding value)
          value)
        (error "inaccessible variable: " variable)))
    (define (evaluate-variable variable)
      (define binding (assoc variable environment))
      (if binding
        (cdr binding)
        (eval variable (interaction-environment))))
    (define (evaluate expression)
      (cond
        ((symbol? expression)
         (evaluate-variable expression))
        ((pair? expression)
         (let ((operator (car expression))
               (operands (cdr expression)))
           (apply
             (case operator
               ((begin) evaluate-begin )
               ((define) evaluate-define)
               ((if) evaluate-if )
               ((lambda) evaluate-lambda)
               ((set!) evaluate-set! )
               (else (evaluate-application operator))) operands)))
        (else
          expression)));
    (display output)
    (newline)
    (display ">>>")
    (loop (evaluate (read))))
  (loop "Slip version 0")
  
  )
